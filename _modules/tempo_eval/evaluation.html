<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tempo_eval.evaluation &mdash; tempo_eval 0.1.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> tempo_eval
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contribute</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../evaluation.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">tempo_eval</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>tempo_eval.evaluation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tempo_eval.evaluation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core functions for evaluating tempo jams.</span>

<span class="sd">This module must not contain any formatting or printing logic.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">walk</span><span class="p">,</span> <span class="n">listdir</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">exists</span><span class="p">,</span> <span class="n">isdir</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">stdev</span><span class="p">,</span> <span class="n">mean</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Set</span>

<span class="kn">import</span> <span class="nn">jams</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">statsmodels.stats.contingency_tables</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">objmode</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">ttest_rel</span>

<span class="kn">import</span> <span class="nn">tempo_eval</span>
<span class="kn">from</span> <span class="nn">tempo_eval.parser.util</span> <span class="kn">import</span> <span class="n">timestamps_to_bpm</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;tempo_eval&#39;</span><span class="p">)</span>

<span class="c1"># type aliases used in functions (type hints)</span>
<span class="c1"># to make autodoc with sphinx a little easier</span>
<span class="n">MirexTempo</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
<span class="n">PlainTempo</span> <span class="o">=</span> <span class="nb">float</span>
<span class="n">Tempo</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">MirexTempo</span><span class="p">,</span> <span class="n">PlainTempo</span><span class="p">]</span>
<span class="n">Tempi</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tempo</span><span class="p">]]</span>
<span class="n">EvalResult</span> <span class="o">=</span> <span class="n">Any</span>
<span class="n">EvalResults</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">EvalResult</span><span class="p">]]]</span>
<span class="n">AverageResults</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]]</span>
<span class="n">Annotations</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">]]</span>
<span class="n">TagAnnotations</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotations</span><span class="p">]</span>


<div class="viewcode-block" id="Metric"><a class="viewcode-back" href="../../generated/tempo_eval.Metric.html#tempo_eval.Metric">[docs]</a><span class="k">class</span> <span class="nc">Metric</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metric.</span>

<span class="sd">    Structured collection of logic and injected functions for different metrics.</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import OE1, read_reference_annotations, read_estimate_annotations</span>
<span class="sd">    &gt;&gt;&gt; gt_ref = read_reference_annotations(&#39;giantsteps_tempo&#39;, validate=False)</span>
<span class="sd">    &gt;&gt;&gt; gt_est = read_estimate_annotations(&#39;giantsteps_tempo&#39;, validate=False)</span>
<span class="sd">    # evaluate estimates using the reference values and Metric OE1:</span>
<span class="sd">    &gt;&gt;&gt; res = OE1.eval_annotations(gt_ref[&#39;tempo&#39;], gt_est[&#39;tempo&#39;])</span>
<span class="sd">    # show result of ref &#39;1.0&#39; and est &#39;davies2009/mirex_qm_tempotracker&#39;</span>
<span class="sd">    # for file &#39;3453642.LOFI.jams&#39;:</span>
<span class="sd">    &gt;&gt;&gt; res[&#39;1.0&#39;][&#39;davies2009/mirex_qm_tempotracker&#39;][&#39;3453642.LOFI.jams&#39;]</span>
<span class="sd">    [-0.02271693594286862]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Metric.__init__"><a class="viewcode-back" href="../../generated/tempo_eval.Metric.html#tempo_eval.Metric.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">formatted_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tempo</span><span class="p">,</span> <span class="n">Tempo</span><span class="p">],</span> <span class="n">EvalResult</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">extract_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">],</span> <span class="n">Tempo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">suitability_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tempo</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">significant_difference_function</span><span class="p">:</span>
                 <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalResult</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalResult</span><span class="p">]],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                          <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">best_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
                 <span class="n">signed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a metric using the given functions.</span>

<span class="sd">        :param name: name</span>
<span class="sd">        :param description: HTML-formatted, high level description</span>
<span class="sd">        :param formatted_name: HTML-formatted name</span>
<span class="sd">        :param eval_function: function that compares two tempi,</span>
<span class="sd">            may also accept a tolerance parameter, e.g. :py:func:`~tempo_eval.equal1`.</span>
<span class="sd">        :param extract_function: function to extract tempo values</span>
<span class="sd">            from annotation, e.g. :py:func:`~tempo_eval.extract_tempo`.</span>
<span class="sd">        :param significant_difference_function: function to determine significant differences.</span>
<span class="sd">            E.g. :py:func:`~tempo_eval.evaluation.mcnemar`.</span>
<span class="sd">        :param suitability_function: function to determine whether</span>
<span class="sd">            a tempo value is suitable for this metric, e.g.</span>
<span class="sd">            :py:func:`~tempo_eval.is_single_bpm`.</span>
<span class="sd">        :param best_value: best value (to show, if no values are available)</span>
<span class="sd">        :param unit: unit, e.g., ``&#39;%&#39;``</span>
<span class="sd">        :param signed: is the metric signed (e.g. percentage error)</span>
<span class="sd">            or absolute (e.g. Accuracy1)?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_value</span> <span class="o">=</span> <span class="n">best_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signed</span> <span class="o">=</span> <span class="n">signed</span>
        <span class="k">if</span> <span class="n">formatted_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formatted_name</span> <span class="o">=</span> <span class="n">formatted_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formatted_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">description</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formatted_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span> <span class="o">=</span> <span class="n">eval_function</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">eval_function</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;eval_function must not be None&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extract_function</span> <span class="o">=</span> <span class="n">extract_function</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">extract_function</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;extract_function must not be None&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suitability_function</span> <span class="o">=</span> <span class="n">suitability_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">significant_difference_function</span> <span class="o">=</span> <span class="n">significant_difference_function</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">_create_eval_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerances</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span>\
            <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Tempo</span><span class="p">,</span> <span class="n">Tempo</span><span class="p">],</span> <span class="n">EvalResult</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a list of functions that each take two arguments, but use</span>
<span class="sd">        different tolerances.</span>

<span class="sd">        :param tolerances: iterable of desired tolerances</span>
<span class="sd">        :return: list of evaluation functions</span>
<span class="sd">        :rtype: list[function]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fixed_tolerance</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">return</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">fixed_tolerance</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tolerances</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_tempo_suitable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tempo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates whether a given tempo is suitable for this metric.</span>
<span class="sd">        This is determined with the instance&#39;s suitability function.</span>

<span class="sd">        :param tempo: tempo value</span>
<span class="sd">        :return: ``True`` or ``False``</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">suitability_function</span><span class="p">(</span><span class="n">tempo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">are_tempi_suitable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tempi</span><span class="p">:</span> <span class="n">Tempi</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is at least one tempo *meant* for this metric?</span>

<span class="sd">        :param tempi: collection of tempi as provided by \</span>
<span class="sd">            :py:func:`~tempo_eval.evaluation.Metric.extract_tempi`</span>
<span class="sd">        :type tempi: dict[str, object)</span>
<span class="sd">        :return: ``True``, if *any* tempi are suitable</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">is_tempo_suitable</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tempi</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="k">def</span> <span class="nf">extract_tempi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotation_set</span><span class="p">:</span> <span class="n">Annotations</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tempi</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts tempi from the given annotation set. This possibly</span>
<span class="sd">        extracts multiple values per track.</span>
<span class="sd">        Uses the ``extract_function`` provided at initialization.</span>

<span class="sd">        :param annotation_set: annotation set</span>
<span class="sd">        :return: dict of dicts with the version/annotationset name on</span>
<span class="sd">            the first level and item ids and their</span>
<span class="sd">            tempi on the second level</span>
<span class="sd">        :rtype: dict[str, dict[str, object]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">version</span><span class="p">:</span> <span class="p">{</span><span class="n">item_id</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_function</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span> <span class="k">for</span> <span class="n">item_id</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="k">for</span> <span class="n">version</span><span class="p">,</span> <span class="n">annotations</span> <span class="ow">in</span> <span class="n">annotation_set</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">def</span> <span class="nf">eval_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_annotation_set</span><span class="p">:</span> <span class="n">Annotations</span><span class="p">,</span>
                         <span class="n">estimates_annotation_set</span><span class="p">:</span> <span class="n">Annotations</span><span class="p">,</span>
                         <span class="n">tolerances</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalResults</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates annotations.</span>

<span class="sd">        :param reference_annotation_set: reference annotations</span>
<span class="sd">        :type reference_annotation_set: dict[str, dict[str, jams.Annotation)</span>
<span class="sd">        :param estimates_annotation_set: estimates</span>
<span class="sd">        :type estimates_annotation_set: dict[str, dict[str, jams.Annotation)</span>
<span class="sd">        :param tolerances: array of tolerances (for metrics that need such a thing)</span>
<span class="sd">        :return: evaluation results (per track)</span>
<span class="sd">        :rtype: dict[str, dict[str, dict[str, object]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reference_tempi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_tempi</span><span class="p">(</span><span class="n">reference_annotation_set</span><span class="p">)</span>
        <span class="n">estimated_tempi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_tempi</span><span class="p">(</span><span class="n">estimates_annotation_set</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_tempi</span><span class="p">(</span><span class="n">reference_tempi</span><span class="p">,</span> <span class="n">estimated_tempi</span><span class="p">,</span> <span class="n">tolerances</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eval_tempi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_tempi</span><span class="p">:</span> <span class="n">Tempi</span><span class="p">,</span>
                   <span class="n">estimated_tempi</span><span class="p">:</span> <span class="n">Tempi</span><span class="p">,</span>
                   <span class="n">tolerances</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EvalResults</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates tempi for all provided tempi for each track.</span>

<span class="sd">        :param reference_tempi: tempi as provided by \</span>
<span class="sd">            :py:func:`~tempo_eval.evaluation.Metric.extract_tempi`</span>
<span class="sd">        :param estimated_tempi: tempi as provided by</span>
<span class="sd">            :py:func:`~tempo_eval.evaluation.Metric.extract_tempi`</span>
<span class="sd">        :param tolerances: array of tolerances to pass to the eval</span>
<span class="sd">            function as third parameter</span>
<span class="sd">        :return: evaluation results (per track) as nested dict with</span>
<span class="sd">            ground truth version, estimator name and item id as keys</span>
<span class="sd">        :rtype: dict[str, dict[str, dict[str, object]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eval_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_eval_functions</span><span class="p">(</span><span class="n">tolerances</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">groundtruth_version</span><span class="p">,</span> <span class="n">specific_reference_tempi</span> <span class="ow">in</span> <span class="n">reference_tempi</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">item_id</span><span class="p">,</span> <span class="n">reference_tempo</span> <span class="ow">in</span> <span class="n">specific_reference_tempi</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">specific_estimated_tempi</span> <span class="ow">in</span> <span class="n">estimated_tempi</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                    <span class="k">if</span> <span class="n">groundtruth_version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">groundtruth_version</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="n">estimator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="n">groundtruth_version</span><span class="p">]:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">groundtruth_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                    <span class="k">if</span> <span class="n">item_id</span> <span class="ow">in</span> <span class="n">specific_estimated_tempi</span><span class="p">:</span>
                        <span class="n">estimated_tempo</span> <span class="o">=</span> <span class="n">specific_estimated_tempi</span><span class="p">[</span><span class="n">item_id</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">estimated_tempo</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">estimated_tempo</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Estimate </span><span class="si">{}</span><span class="s1"> BPM by </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> for </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> is &lt;= 0.0 BPM. &#39;</span>
                                           <span class="s1">&#39;Reference tempo in </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> &#39;</span>
                                           <span class="s1">&#39;is </span><span class="si">{}</span><span class="s1"> BPM. &#39;</span>
                                           <span class="s1">&#39;We will ignore this estimate and treat it as </span><span class="se">\&#39;</span><span class="s1">no value</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">estimated_tempo</span><span class="p">,</span>
                                                   <span class="n">estimator</span><span class="p">,</span> <span class="n">item_id</span><span class="p">,</span>
                                                   <span class="n">groundtruth_version</span><span class="p">,</span>
                                                   <span class="n">reference_tempo</span><span class="p">))</span>
                            <span class="n">estimated_tempo</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="c1"># TODO: What, if it&#39;s a tuple for PScore, not a float?</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Failed to find item </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> in estimates by </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span>
                                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item_id</span><span class="p">,</span> <span class="n">estimator</span><span class="p">))</span>
                        <span class="n">estimated_tempo</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="n">comparison_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">eval_function</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span>
                                                        <span class="n">estimated_tempo</span><span class="p">)</span>
                                          <span class="k">for</span> <span class="n">eval_function</span> <span class="ow">in</span> <span class="n">eval_functions</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">comparison_results</span><span class="p">)):</span>
                        <span class="k">with</span> <span class="n">objmode</span><span class="p">():</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Metric </span><span class="si">{}</span><span class="s1"> returned nan: &#39;</span>
                                           <span class="s1">&#39;item=</span><span class="si">{}</span><span class="s1">, estimator=</span><span class="si">{}</span><span class="s1">, estimate=</span><span class="si">{}</span><span class="s1"> BPM, &#39;</span>
                                           <span class="s1">&#39;reference_version=</span><span class="si">{}</span><span class="s1">, reference=</span><span class="si">{}</span><span class="s1"> BPM&#39;</span>
                                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                   <span class="n">item_id</span><span class="p">,</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span>
                                                   <span class="n">groundtruth_version</span><span class="p">,</span> <span class="n">reference_tempo</span><span class="p">))</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">groundtruth_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">][</span><span class="n">item_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">comparison_results</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">averages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_results</span><span class="p">:</span> <span class="n">EvalResults</span><span class="p">,</span>
                 <span class="n">item_id_filter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">undefined_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AverageResults</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate means and standard deviations for the given evaluation results.</span>
<span class="sd">        Possible INF and NaN values will be masked, i.e., ignored.</span>
<span class="sd">        This means that if an algorithms did not produce a valid estimate, averages</span>
<span class="sd">        and standard deviations will be computed without that value.</span>

<span class="sd">        :param undefined_value: value to use, if no data is available. Defaults to</span>
<span class="sd">            ``self.best_value``.</span>
<span class="sd">        :param eval_results: results as returned by</span>
<span class="sd">            :py:func:`~tempo_eval.evaluation.Metric.eval_tempi`</span>
<span class="sd">        :param item_id_filter: function taking reference name and item id as arguments to filter item ids</span>
<span class="sd">        :return: mean and standard deviation as nested dict with</span>
<span class="sd">            ground truth version and estimator name as keys</span>
<span class="sd">        :rtype: dict[str, dict[str, (list[float], list[float])]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">undefined_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">undefined_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_value</span>
        <span class="n">averages</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">groundtruth_version</span><span class="p">,</span> <span class="n">algorithms</span> <span class="ow">in</span> <span class="n">eval_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">estimator</span><span class="p">,</span> <span class="n">results</span> <span class="ow">in</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">groundtruth_version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">averages</span><span class="p">:</span>
                    <span class="n">averages</span><span class="p">[</span><span class="n">groundtruth_version</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">filtered_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">value</span>
                                            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                            <span class="k">if</span> <span class="n">item_id_filter</span><span class="p">(</span><span class="n">groundtruth_version</span><span class="p">,</span> <span class="n">key</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">filtered_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">averages</span><span class="p">[</span><span class="n">groundtruth_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">undefined_value</span><span class="p">],</span> <span class="p">[</span><span class="n">undefined_value</span><span class="p">]</span>
                    <span class="k">continue</span>

                <span class="c1"># mask invalid, because APE can be INF and OE can be NaN</span>
                <span class="n">masked_invalid_filtered_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">filtered_values</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">masked_invalid_filtered_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">masked_invalid_filtered_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">averages</span><span class="p">[</span><span class="n">groundtruth_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">averages</span></div>


<div class="viewcode-block" id="equal1"><a class="viewcode-back" href="../../generated_functions/tempo_eval.equal1.html#tempo_eval.equal1">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">equal1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
           <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
           <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.04</span><span class="p">,</span>
           <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines whether two tempi are considered *equal*, given an allowed tolerance</span>
<span class="sd">    and factor.</span>

<span class="sd">    When averaged, results correspond to *Accuracy 1*.</span>

<span class="sd">    See also :py:func:`~tempo_eval.equal2`.</span>

<span class="sd">    :param reference_tempo: references tempo</span>
<span class="sd">    :param estimated_tempo: estimated tempo</span>
<span class="sd">    :param tolerance: tolerance, default is 0.04, i.e., 4%</span>
<span class="sd">    :param factor: allowed deviation factor</span>
<span class="sd">    :return: ``True`` or ``False``</span>
<span class="sd">    :rtype: bool</span>

<span class="sd">    .. seealso:: Fabien Gouyon, Anssi P. Klapuri, Simon Dixon, Miguel Alonso,</span>
<span class="sd">        George Tzanetakis, Christian Uhle, and Pedro Cano. `An experimental</span>
<span class="sd">        comparison of audio tempo induction algorithms.</span>
<span class="sd">        &lt;https://www.researchgate.net/profile/Fabien_Gouyon/publication/3457642_An_experimental_comparison_of_audio_tempo_induction_algorithms/links/0fcfd50d982025360f000000/An-experimental-comparison-of-audio-tempo-induction-algorithms.pdf&gt;`_</span>
<span class="sd">        IEEE Transactions on Audio, Speech, and Language Processing,</span>
<span class="sd">        14(5):1832– 1844, 2006.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">tolerance</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tolerance</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Tolerance must be in [0, 1]&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">reference_tempo</span><span class="o">*</span><span class="n">factor</span><span class="o">-</span><span class="n">estimated_tempo</span><span class="p">)</span>\
           <span class="o">&lt;=</span> <span class="p">(</span><span class="n">reference_tempo</span><span class="o">*</span><span class="n">factor</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="equal2"><a class="viewcode-back" href="../../generated_functions/tempo_eval.equal2.html#tempo_eval.equal2">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">equal2</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
           <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
           <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.04</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines whether two tempi are considered *equal*, given an allowed tolerance</span>
<span class="sd">    and the factors 1, 2, 3, 1/2, and 1/3.</span>

<span class="sd">    When averaged, results correspond to *Accuracy 2*.</span>

<span class="sd">    See also :py:func:`~tempo_eval.equal1`.</span>

<span class="sd">    :param reference_tempo: reference tempo</span>
<span class="sd">    :param estimated_tempo: estimated tempo</span>
<span class="sd">    :param tolerance: tolerance, default is ``0.04``, i.e., 4%</span>
<span class="sd">    :return: ``True`` or ``False``</span>
<span class="sd">    :rtype: bool</span>

<span class="sd">    .. seealso:: Fabien Gouyon, Anssi P. Klapuri, Simon Dixon, Miguel Alonso,</span>
<span class="sd">        George Tzanetakis, Christian Uhle, and Pedro Cano. `An experimental</span>
<span class="sd">        comparison of audio tempo induction algorithms.</span>
<span class="sd">        &lt;https://www.researchgate.net/profile/Fabien_Gouyon/publication/3457642_An_experimental_comparison_of_audio_tempo_induction_algorithms/links/0fcfd50d982025360f000000/An-experimental-comparison-of-audio-tempo-induction-algorithms.pdf&gt;`_</span>
<span class="sd">        IEEE Transactions on Audio, Speech, and Language Processing,</span>
<span class="sd">        14(5):1832– 1844, 2006.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">equal1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="n">equal1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="n">equal1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="n">equal1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="n">equal1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span></div>


<div class="viewcode-block" id="p_score"><a class="viewcode-back" href="../../generated_functions/tempo_eval.p_score.html#tempo_eval.p_score">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">p_score</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">MirexTempo</span><span class="p">,</span>
            <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MirexTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
            <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.08</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    P-Score is the weighted average of two tempi values.</span>
<span class="sd">    The weighting is based on a salience value (part of the ground truth).</span>

<span class="sd">    See also :py:func:`~tempo_eval.one_correct` and</span>
<span class="sd">    :py:func:`~tempo_eval.both_correct`.</span>

<span class="sd">    :param reference_tempo: (t1, t2, s1)</span>
<span class="sd">    :param estimated_tempo: (t1, t2, s1)</span>
<span class="sd">    :param tolerance: tolerance, e.g., ``0.08``</span>
<span class="sd">    :return: score :math:`\in [0,1]`</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    .. seealso::</span>
<span class="sd">        * McKinney, M. F., Moelants, D., Davies, M. E., and Klapuri, A. P. (2007).</span>
<span class="sd">          `Evaluation of audio beat tracking and music tempo extraction algorithms.</span>
<span class="sd">          &lt;http://www.cs.tut.fi/sgn/arg/klap/mckinney_jnmr07.pdf&gt;`_</span>
<span class="sd">          Journal of New Music Research, 36(1):1–16.</span>
<span class="sd">        * `MIREX Audio Tempo Extraction 2006</span>
<span class="sd">          &lt;https://www.music-ir.org/mirex/wiki/2006:Audio_Tempo_Extraction&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mirex</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span>
                  <span class="n">estimated_tempo</span><span class="p">,</span>
                  <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="one_correct"><a class="viewcode-back" href="../../generated_functions/tempo_eval.one_correct.html#tempo_eval.one_correct">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">one_correct</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">MirexTempo</span><span class="p">,</span>
                <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MirexTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.08</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fraction of estimates with at least one correct tempo value.</span>

<span class="sd">    See also :py:func:`~tempo_eval.p_score` and</span>
<span class="sd">    :py:func:`~tempo_eval.both_correct`.</span>

<span class="sd">    :param reference_tempo: (t1, t2, s1)</span>
<span class="sd">    :param estimated_tempo: (t1, t2, s1)</span>
<span class="sd">    :param tolerance: tolerance, e.g., ``0.08``</span>
<span class="sd">    :return: fraction :math:`\in [0,1]`</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mirex</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span>
                  <span class="n">estimated_tempo</span><span class="p">,</span>
                  <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="both_correct"><a class="viewcode-back" href="../../generated_functions/tempo_eval.both_correct.html#tempo_eval.both_correct">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">both_correct</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">MirexTempo</span><span class="p">,</span>
                 <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MirexTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
                 <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.08</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fraction of estimates with two correct tempo values.</span>

<span class="sd">    See also :py:func:`~tempo_eval.p_score` and</span>
<span class="sd">    :py:func:`~tempo_eval.one_correct`.</span>

<span class="sd">    :param reference_tempo: (t1, t2, s1)</span>
<span class="sd">    :param estimated_tempo: (t1, t2, s1)</span>
<span class="sd">    :param tolerance: tolerance, e.g., ``0.08``</span>
<span class="sd">    :return: fraction :math:`\in [0,1]`</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mirex</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span>
                  <span class="n">estimated_tempo</span><span class="p">,</span>
                  <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span></div>


<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_mirex</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">MirexTempo</span><span class="p">,</span>
           <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MirexTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
           <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.08</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># for now call our own implementation, to avoid stumbling over</span>
        <span class="c1"># 0 values. See https://github.com/craffel/mir_eval/issues/298</span>
        <span class="k">return</span> <span class="n">_mir_eval_detection</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">reference_tempo</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">estimated_tempo</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="c1"># but we actually want to call mir_eval.tempo.detection</span>
        <span class="c1"># return mir_eval.tempo.detection(np.array([reference_tempo[0], reference_tempo[1]]), reference_tempo[2],</span>
        <span class="c1">#                                 np.array([estimated_tempo[0], estimated_tempo[1]]), tol=tolerance)</span>


<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_mir_eval_detection</span><span class="p">(</span><span class="n">reference_tempi</span><span class="p">:</span> <span class="n">MirexTempo</span><span class="p">,</span>
                        <span class="n">reference_weight</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                        <span class="n">estimated_tempi</span><span class="p">:</span> <span class="n">MirexTempo</span><span class="p">,</span>
                        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.08</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function copied from mir_eval.tempo.detection minus the validation.</span>

<span class="sd">    :param reference_tempi: np.ndarray, shape=(2,)</span>
<span class="sd">        Two non-negative reference tempi</span>
<span class="sd">    :param reference_weight: float &gt; 0</span>
<span class="sd">        The relative strength of ``reference_tempi[0]`` vs</span>
<span class="sd">        ``reference_tempi[1]``.</span>
<span class="sd">    :param estimated_tempi: np.ndarray, shape=(2,)</span>
<span class="sd">        Two non-negative estimated tempi.</span>
<span class="sd">    :param tol: float in [0, 1]:</span>
<span class="sd">        The maximum allowable deviation from a reference tempo to</span>
<span class="sd">        count as a hit.</span>
<span class="sd">        ``|est_t - ref_t| &lt;= tol * ref_t``</span>
<span class="sd">        (Default value = 0.08)</span>
<span class="sd">    :return: p_score, one_correct, both_correct</span>
<span class="sd">    :rtype: (float, bool, bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tol</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid tolerance </span><span class="si">{}</span><span class="s1">: must lie in the range &#39;</span>
                         <span class="s1">&#39;[0, 1]&#39;</span><span class="p">)</span>

    <span class="n">hits</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

    <span class="c1"># avoid numpy, as it is slow for such small arrays, roughly factor 4</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ref_t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reference_tempi</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ref_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Compute the relative error for this reference tempo</span>
            <span class="n">relative_error</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="nb">abs</span><span class="p">(</span><span class="n">ref_t</span> <span class="o">-</span> <span class="n">estimated_tempi</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="nb">abs</span><span class="p">(</span><span class="n">ref_t</span> <span class="o">-</span> <span class="n">estimated_tempi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ref_t</span><span class="p">)</span>
            <span class="c1"># Count the hits</span>
            <span class="n">hits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">relative_error</span> <span class="o">&lt;=</span> <span class="n">tol</span>

    <span class="n">score</span> <span class="o">=</span> <span class="n">reference_weight</span> <span class="o">*</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">reference_weight</span><span class="p">)</span> <span class="o">*</span> <span class="n">hits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">one</span> <span class="o">=</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">hits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">both</span> <span class="o">=</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">hits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">hits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">both</span>


<div class="viewcode-block" id="pe1"><a class="viewcode-back" href="../../generated_functions/tempo_eval.pe1.html#tempo_eval.pe1">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">pe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
        <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Percentage error for two tempi values allowing for a given factor.</span>
<span class="sd">    If a reference tempo of 0 is given, this function returns NaN.</span>
<span class="sd">    If an estimate of None is given, this function returns NaN.</span>

<span class="sd">    See also :py:func:`~tempo_eval.pe2`.</span>

<span class="sd">    :param reference_tempo: a reference tempo, should not be 0</span>
<span class="sd">    :param estimated_tempo: an estimated tempo</span>
<span class="sd">    :param factor: multiplication factor</span>
<span class="sd">    :return: the percentage error</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">reference_tempo</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">estimated_tempo</span><span class="o">*</span><span class="n">factor</span><span class="o">-</span><span class="n">reference_tempo</span><span class="p">)</span><span class="o">/</span><span class="n">reference_tempo</span></div>


<div class="viewcode-block" id="pe2"><a class="viewcode-back" href="../../generated_functions/tempo_eval.pe2.html#tempo_eval.pe2">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">pe2</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
        <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Percentage error for two tempi values allowing the factors</span>
<span class="sd">    1, 2, 3, 1/2, and 1/3 with the smallest absolute value.</span>
<span class="sd">    If an estimate of None is given, this function returns NaN.</span>

<span class="sd">    See also :py:func:`~tempo_eval.pe1`.</span>

<span class="sd">    :param reference_tempo: a references tempo, must not be 0</span>
<span class="sd">    :param estimated_tempo: an estimated tempo</span>
<span class="sd">    :return: the percentage error for the factors 1, 2, 3, 1/2, and 1/3 with the smallest absolute value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">pe1_1</span> <span class="o">=</span> <span class="n">pe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">)</span>
    <span class="n">pe1_2</span> <span class="o">=</span> <span class="n">pe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">pe1_12</span> <span class="o">=</span> <span class="n">pe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">pe1_3</span> <span class="o">=</span> <span class="n">pe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">3.</span><span class="p">)</span>
    <span class="n">pe1_13</span> <span class="o">=</span> <span class="n">pe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>

    <span class="n">pe1s</span> <span class="o">=</span> <span class="p">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">pe1_1</span><span class="p">):</span> <span class="n">pe1_1</span><span class="p">,</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">pe1_2</span><span class="p">):</span> <span class="n">pe1_2</span><span class="p">,</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">pe1_12</span><span class="p">):</span> <span class="n">pe1_12</span><span class="p">,</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">pe1_3</span><span class="p">):</span> <span class="n">pe1_3</span><span class="p">,</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">pe1_13</span><span class="p">):</span> <span class="n">pe1_13</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">pe1s</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">pe1s</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span></div>


<div class="viewcode-block" id="ape1"><a class="viewcode-back" href="../../generated_functions/tempo_eval.ape1.html#tempo_eval.ape1">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">ape1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
         <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
         <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Absolute percentage error for two tempi values allowing for a given factor.</span>
<span class="sd">    If a reference tempo of 0 is given, this function returns NaN.</span>
<span class="sd">    If an estimate of None is given, this function returns NaN.</span>

<span class="sd">    When averaged, results correspond to *MAPE1*.</span>

<span class="sd">    See also :py:func:`~tempo_eval.ape2`.</span>

<span class="sd">    :param reference_tempo: a reference tempo, should not be 0</span>
<span class="sd">    :param estimated_tempo: an estimated tempo</span>
<span class="sd">    :param factor: multiplication factor</span>
<span class="sd">    :return: the absolute percentage error</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="o">=</span><span class="n">reference_tempo</span><span class="p">,</span>
                   <span class="n">estimated_tempo</span><span class="o">=</span><span class="n">estimated_tempo</span><span class="p">,</span>
                   <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">))</span></div>


<div class="viewcode-block" id="ape2"><a class="viewcode-back" href="../../generated_functions/tempo_eval.ape2.html#tempo_eval.ape2">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">ape2</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
         <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimum of the absolute percentage error for two tempi values allowing the factors</span>
<span class="sd">    1, 2, 3, 1/2, and 1/3.</span>
<span class="sd">    If an estimate of None is given, this function returns NaN.</span>

<span class="sd">    When averaged, results correspond to *MAPE2*.</span>

<span class="sd">    See also :py:func:`~tempo_eval.ape1`.</span>

<span class="sd">    :param reference_tempo: a references tempo, must not be 0</span>
<span class="sd">    :param estimated_tempo: an estimated tempo</span>
<span class="sd">    :return: the minimal absolute percentage error for the factors 1, 2, 3, 1/2, and 1/3.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span>
        <span class="n">ape1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">),</span>
        <span class="n">ape1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">2.</span><span class="p">),</span>
        <span class="n">ape1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span>
        <span class="n">ape1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">3.</span><span class="p">),</span>
        <span class="n">ape1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="oe1"><a class="viewcode-back" href="../../generated_functions/tempo_eval.oe1.html#tempo_eval.oe1">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">oe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
        <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Octave error for two tempi values allowing for a given factor.</span>
<span class="sd">    If a reference or estimated tempo of 0 is given, this function returns NaN.</span>
<span class="sd">    If an estimate of None is given, this function returns NaN.</span>

<span class="sd">    See also :py:func:`~tempo_eval.oe2`.</span>

<span class="sd">    :param reference_tempo: a reference tempo, should not be 0</span>
<span class="sd">    :param estimated_tempo: an estimated tempo</span>
<span class="sd">    :param factor: multiplication factor</span>
<span class="sd">    :return: the octave error</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">reference_tempo</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">estimated_tempo</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">((</span><span class="n">estimated_tempo</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="o">/</span> <span class="n">reference_tempo</span><span class="p">)</span></div>


<div class="viewcode-block" id="oe2"><a class="viewcode-back" href="../../generated_functions/tempo_eval.oe2.html#tempo_eval.oe2">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">oe2</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
        <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Octave error for two tempi values allowing the factors</span>
<span class="sd">    1, 2, 3, 1/2, and 1/3 with the smallest absolute value.</span>
<span class="sd">    If an estimate of None is given, this function returns NaN.</span>

<span class="sd">    See also :py:func:`~tempo_eval.oe1`.</span>

<span class="sd">    :param reference_tempo: a references tempo, must not be 0</span>
<span class="sd">    :param estimated_tempo: an estimated tempo</span>
<span class="sd">    :return: the percentage error for the factors 1, 2, 3, 1/2, and 1/3 with the smallest absolute value</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">oe1_1</span> <span class="o">=</span> <span class="n">oe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">)</span>
    <span class="n">oe1_2</span> <span class="o">=</span> <span class="n">oe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">oe1_12</span> <span class="o">=</span> <span class="n">oe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">oe1_3</span> <span class="o">=</span> <span class="n">oe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">3.</span><span class="p">)</span>
    <span class="n">oe1_13</span> <span class="o">=</span> <span class="n">oe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>

    <span class="n">oe1s</span> <span class="o">=</span> <span class="p">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">oe1_1</span><span class="p">):</span> <span class="n">oe1_1</span><span class="p">,</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">oe1_2</span><span class="p">):</span> <span class="n">oe1_2</span><span class="p">,</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">oe1_12</span><span class="p">):</span> <span class="n">oe1_12</span><span class="p">,</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">oe1_3</span><span class="p">):</span> <span class="n">oe1_3</span><span class="p">,</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">oe1_13</span><span class="p">):</span> <span class="n">oe1_13</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">oe1s</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">oe1s</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span></div>


<div class="viewcode-block" id="aoe1"><a class="viewcode-back" href="../../generated_functions/tempo_eval.aoe1.html#tempo_eval.aoe1">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">aoe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
         <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
         <span class="n">factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Absolute octave error for two tempi values allowing for a given factor.</span>
<span class="sd">    If a reference or estimated tempo of 0 is given, this function returns NaN.</span>
<span class="sd">    If an estimate of None is given, this function returns NaN.</span>

<span class="sd">    When averaged, results correspond to *MAOE1*.</span>

<span class="sd">    See also :py:func:`~tempo_eval.aoe2`.</span>

<span class="sd">    :param reference_tempo: a reference tempo, should not be 0</span>
<span class="sd">    :param estimated_tempo: an estimated tempo, should not be 0</span>
<span class="sd">    :param factor: multiplication factor</span>
<span class="sd">    :return: the absolute octave error</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">oe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="o">=</span><span class="n">reference_tempo</span><span class="p">,</span>
                   <span class="n">estimated_tempo</span><span class="o">=</span><span class="n">estimated_tempo</span><span class="p">,</span>
                   <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">))</span></div>


<div class="viewcode-block" id="aoe2"><a class="viewcode-back" href="../../generated_functions/tempo_eval.aoe2.html#tempo_eval.aoe2">[docs]</a><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">aoe2</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">:</span> <span class="n">PlainTempo</span><span class="p">,</span>
         <span class="n">estimated_tempo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimum of the absolute octave error for two tempi values allowing the factors</span>
<span class="sd">    1, 2, 3, 1/2, and 1/3.</span>
<span class="sd">    If an estimate of None is given, this function returns NaN.</span>

<span class="sd">    When averaged, results correspond to *MAOE2*.</span>

<span class="sd">    See also :py:func:`~tempo_eval.aoe1`.</span>

<span class="sd">    :param reference_tempo: a references tempo, must not be 0</span>
<span class="sd">    :param estimated_tempo: an estimated tempo, must not be 0</span>
<span class="sd">    :return: the minimal absolute percentage error for the factors 1, 2, 3, 1/2, and 1/3.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">estimated_tempo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span>
        <span class="n">aoe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">),</span>
        <span class="n">aoe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">2.</span><span class="p">),</span>
        <span class="n">aoe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span>
        <span class="n">aoe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">3.</span><span class="p">),</span>
        <span class="n">aoe1</span><span class="p">(</span><span class="n">reference_tempo</span><span class="p">,</span> <span class="n">estimated_tempo</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="is_mirex_style"><a class="viewcode-back" href="../../generated/tempo_eval.is_mirex_style.html#tempo_eval.is_mirex_style">[docs]</a><span class="k">def</span> <span class="nf">is_mirex_style</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Tempo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Does the given tempo have MIREX style, i.e., ``(t1, t2, s1)`` with</span>
<span class="sd">    t1 and t2 not equal to 0 and s1 neither 0 or 1.</span>
<span class="sd">    Returns ``False`` for values equal to or less than 0 and greater than 5000.</span>
<span class="sd">    The upper bound is chosen somewhat arbitrarily.</span>
<span class="sd">    Note that a value like ``(0, 100, 0)`` is not good enough.</span>

<span class="sd">    :param t: tempo list-like object</span>
<span class="sd">    :return: ``True`` or ``False``</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> \
               <span class="ow">and</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">5000.</span> \
               <span class="ow">and</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">5000.</span> \
               <span class="ow">and</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> \
               <span class="ow">and</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1.</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="is_single_bpm"><a class="viewcode-back" href="../../generated/tempo_eval.is_single_bpm.html#tempo_eval.is_single_bpm">[docs]</a><span class="k">def</span> <span class="nf">is_single_bpm</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Tempo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is the given tempo a plausible BPM value?</span>
<span class="sd">    Returns ``False`` for values less than 0 and greater than 5000.</span>
<span class="sd">    The upper bound is chosen somewhat arbitrarily.</span>

<span class="sd">    :param t: tempo</span>
<span class="sd">    :return: ``True`` or ``False``</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mf">5000.</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get real path for a packaged data file.</span>

<span class="sd">    :param file_name: file name</span>
<span class="sd">    :return: fill path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">packagedir</span> <span class="o">=</span> <span class="n">tempo_eval</span><span class="o">.</span><span class="n">__path__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">packagedir</span><span class="p">),</span> <span class="n">file_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fullname</span>


<div class="viewcode-block" id="get_references_path"><a class="viewcode-back" href="../../generated/tempo_eval.get_references_path.html#tempo_eval.get_references_path">[docs]</a><span class="k">def</span> <span class="nf">get_references_path</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">folder_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get real path for a reference data set.</span>

<span class="sd">    :param dataset: dataset name</span>
<span class="sd">    :param folder_name: folder name</span>
<span class="sd">    :param file_name: file name</span>
<span class="sd">    :return: path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rel_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;references&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">file_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rel_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">rel_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_data</span><span class="p">(</span><span class="n">rel_path</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_data</span><span class="p">(</span><span class="n">rel_path</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span></div>


<div class="viewcode-block" id="get_estimates_path"><a class="viewcode-back" href="../../generated/tempo_eval.get_estimates_path.html#tempo_eval.get_estimates_path">[docs]</a><span class="k">def</span> <span class="nf">get_estimates_path</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">folder_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get real path for an estimates data set.</span>

<span class="sd">    :param dataset: dataset name</span>
<span class="sd">    :param folder_name: folder name</span>
<span class="sd">    :param file_name: file name</span>
<span class="sd">    :return: path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rel_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;estimates&#39;</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">folder_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rel_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">rel_path</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">file_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rel_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">rel_path</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_data</span><span class="p">(</span><span class="n">rel_path</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_data</span><span class="p">(</span><span class="n">rel_path</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span></div>


<div class="viewcode-block" id="list_reference_corpus_names"><a class="viewcode-back" href="../../generated/tempo_eval.list_reference_corpus_names.html#tempo_eval.list_reference_corpus_names">[docs]</a><span class="k">def</span> <span class="nf">list_reference_corpus_names</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List of corpus names for (built-in) references datasets.</span>
<span class="sd">    Instead of the actual jam annotation_metadata corpus name,</span>
<span class="sd">    we use the names of the base directories of the references</span>
<span class="sd">    repository, as this allows us listing them without parsing</span>
<span class="sd">    the whole tree.</span>

<span class="sd">    Additionally, using directory names lets us better control</span>
<span class="sd">    the spelling of corpus names, as we don&#39;t have to rely on</span>
<span class="sd">    what&#39;s in many many jam files.</span>

<span class="sd">    :return: sorted list of corpus names for reference datasets</span>
<span class="sd">    :rtype: list[str]</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import list_reference_corpus_names</span>
<span class="sd">    &gt;&gt;&gt; list_reference_corpus_names()</span>
<span class="sd">    [&#39;acm_mirum&#39;, &#39;ballroom&#39;, &#39;beatles&#39;, &#39;fma_medium&#39;, &#39;fma_small&#39;,</span>
<span class="sd">    &#39;giantsteps_mtg_key&#39;, &#39;giantsteps_tempo&#39;, &#39;gtzan&#39;, &#39;hainsworth&#39;,</span>
<span class="sd">    &#39;ismir2004songs&#39;, &#39;klapuri&#39;, &#39;lmd_tempo&#39;, &#39;rwc_mdb_c&#39;, &#39;rwc_mdb_g&#39;,</span>
<span class="sd">    &#39;rwc_mdb_j&#39;, &#39;rwc_mdb_p&#39;, &#39;rwc_mdb_r&#39;, &#39;smc_mirex&#39;, &#39;wjd&#39;]</span>

<span class="sd">    .. seealso:: To actually read annotations, use</span>
<span class="sd">        :py:func:`~tempo_eval.read_reference_annotations`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">tempo_eval</span><span class="o">.</span><span class="n">__path__</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;references&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isdir</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">e</span><span class="p">))])</span></div>


<div class="viewcode-block" id="list_estimate_corpus_names"><a class="viewcode-back" href="../../generated/tempo_eval.list_estimate_corpus_names.html#tempo_eval.list_estimate_corpus_names">[docs]</a><span class="k">def</span> <span class="nf">list_estimate_corpus_names</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List of corpus names for (built-in) estimates.</span>
<span class="sd">    Instead of the actual jam annotation_metadata corpus name,</span>
<span class="sd">    we use the names of the base directories of the estimates</span>
<span class="sd">    repository, as this allows us listing them without parsing</span>
<span class="sd">    the whole tree.</span>

<span class="sd">    Additionally, using directory names lets us better control</span>
<span class="sd">    the spelling of corpus names, as we don&#39;t have to rely on</span>
<span class="sd">    what&#39;s in many many jam files.</span>

<span class="sd">    :return: sorted list of corpus names for estimate datasets</span>
<span class="sd">    :rtype: list[str]</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import list_estimate_corpus_names</span>
<span class="sd">    &gt;&gt;&gt; list_estimate_corpus_names()</span>
<span class="sd">    [&#39;acm_mirum&#39;, &#39;ballroom&#39;, &#39;beatles&#39;, &#39;fma_medium&#39;, &#39;fma_small&#39;,</span>
<span class="sd">    &#39;giantsteps_mtg_key&#39;, &#39;giantsteps_tempo&#39;, &#39;gtzan&#39;, &#39;hainsworth&#39;,</span>
<span class="sd">    &#39;ismir2004songs&#39;, &#39;lmd_tempo&#39;, &#39;queen&#39;, &#39;rwc_mdb_c&#39;, &#39;rwc_mdb_g&#39;,</span>
<span class="sd">    &#39;rwc_mdb_j&#39;, &#39;rwc_mdb_p&#39;, &#39;rwc_mdb_r&#39;, &#39;smc_mirex&#39;, &#39;wjd&#39;]</span>

<span class="sd">    .. seealso:: To actually read estimates, use</span>
<span class="sd">        :py:func:`~tempo_eval.read_estimate_annotations`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">tempo_eval</span><span class="o">.</span><span class="n">__path__</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s1">&#39;estimates&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isdir</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">e</span><span class="p">))])</span></div>


<div class="viewcode-block" id="read_annotations"><a class="viewcode-back" href="../../generated/tempo_eval.read_annotations.html#tempo_eval.read_annotations">[docs]</a><span class="k">def</span> <span class="nf">read_annotations</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                     <span class="n">derive_version</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">namespace</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;tempo&#39;</span><span class="p">,</span>
                     <span class="n">derive_item_id</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jams</span><span class="o">.</span><span class="n">JAMS</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">file</span><span class="p">,</span> <span class="n">jam</span><span class="p">:</span> <span class="n">basename</span><span class="p">(</span><span class="n">file</span><span class="p">),</span>
                     <span class="n">validate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">split_by_corpus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotations</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotations</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively read all jam files from the given directory.</span>

<span class="sd">    :param path: base directory</span>
<span class="sd">    :param derive_version: function that derives a version a given annotation</span>
<span class="sd">    :param namespace: one or more jam annotation namespace(s), e.g., ``tempo`` for tempo annotations</span>
<span class="sd">    :param derive_item_id: function that returns an id given a file name and jams</span>
<span class="sd">    :param validate: validate jam while reading (validation impacts performance negatively)</span>
<span class="sd">    :param split_by_corpus: wrap results in a dict with corpus names (extracted from jams) as keys</span>
<span class="sd">    :return: jam annotation objects, organized as nested dicts with version and item ids as keys,</span>
<span class="sd">        if ``split_by_corpus`` the outermost dict uses corpus names as keys</span>
<span class="sd">    :raises FileNotFoundError: if ``path`` does not exist or is not a directory</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Reading annotations from </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> ...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;Annotations path does not exist: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="s1">&#39;Annotations path is not a directory: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

    <span class="n">annotations</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">file_names</span><span class="p">)</span> <span class="ow">in</span> <span class="n">walk</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">file_names</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.jams&#39;</span><span class="p">)]:</span>
            <span class="n">jam_file_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">jam</span> <span class="o">=</span> <span class="n">jams</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">jam_file_name</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">)</span>
                <span class="n">item_id</span> <span class="o">=</span> <span class="n">derive_item_id</span><span class="p">(</span><span class="n">jam_file_name</span><span class="p">,</span> <span class="n">jam</span><span class="p">)</span>
                <span class="n">namespace_iterable</span> <span class="o">=</span> <span class="p">[</span><span class="n">namespace</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">namespace</span>

                <span class="k">for</span> <span class="n">ns</span> <span class="ow">in</span> <span class="n">namespace_iterable</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">jam</span><span class="o">.</span><span class="n">annotations</span><span class="p">[</span><span class="n">ns</span><span class="p">]:</span>
                        <span class="c1"># normalize corpus name slightly..</span>
                        <span class="n">corpus</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">annotation_metadata</span><span class="o">.</span><span class="n">corpus</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">split_by_corpus</span> <span class="ow">and</span> <span class="n">corpus</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
                            <span class="n">annotations</span><span class="p">[</span><span class="n">corpus</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                        <span class="n">base</span> <span class="o">=</span> <span class="n">annotations</span><span class="p">[</span><span class="n">corpus</span><span class="p">]</span> <span class="k">if</span> <span class="n">split_by_corpus</span> <span class="k">else</span> <span class="n">annotations</span>

                        <span class="k">if</span> <span class="n">ns</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base</span><span class="p">:</span>
                            <span class="n">base</span><span class="p">[</span><span class="n">ns</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">if</span> <span class="n">derive_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">version</span> <span class="o">=</span> <span class="n">_get_version</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">split_by_corpus</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">version</span> <span class="o">=</span> <span class="n">derive_version</span><span class="p">(</span><span class="n">jam_file_name</span><span class="p">,</span> <span class="n">annotation</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base</span><span class="p">[</span><span class="n">ns</span><span class="p">]:</span>
                            <span class="n">base</span><span class="p">[</span><span class="n">ns</span><span class="p">][</span><span class="n">version</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">if</span> <span class="n">item_id</span> <span class="ow">in</span> <span class="n">base</span><span class="p">[</span><span class="n">ns</span><span class="p">][</span><span class="n">version</span><span class="p">]:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Found multiple </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">-annotations with the same version (</span><span class="si">{}</span><span class="s1">) for &#39;</span>
                                           <span class="s1">&#39;item </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">. Ignoring all but the first one.&#39;</span>
                                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">item_id</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">base</span><span class="p">[</span><span class="n">ns</span><span class="p">][</span><span class="n">version</span><span class="p">][</span><span class="n">item_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">annotation</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Error while parsing JAMS file </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">jam_file_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">e</span>

    <span class="k">return</span> <span class="n">annotations</span></div>


<div class="viewcode-block" id="read_reference_annotations"><a class="viewcode-back" href="../../generated/tempo_eval.read_reference_annotations.html#tempo_eval.read_reference_annotations">[docs]</a><span class="k">def</span> <span class="nf">read_reference_annotations</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                               <span class="n">namespace</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;tempo&#39;</span><span class="p">,</span>
                               <span class="n">validate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotations</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read annotations for reference datasets.</span>

<span class="sd">    :param corpus_name: corpus name (corresponds to folder name).</span>
<span class="sd">        See :py:func:`~tempo_eval.list_reference_corpus_names` to get a list of valid names.</span>
<span class="sd">    :param namespace: one or more jam annotation namespace(s), e.g., ``tempo`` for tempo annotations</span>
<span class="sd">        (see `jams namespaces &lt;https://jams.readthedocs.io/en/stable/namespace.html#namespace&gt;`_)</span>
<span class="sd">    :param validate: validate jam while reading (validation impacts performance negatively)</span>
<span class="sd">    :return: jam annotation objects, organized as nested dicts with version and item ids as keys</span>
<span class="sd">    :rtype: dict[str, dict[str, jams.Annotation]]</span>

<span class="sd">    .. note:: By default, `validate` is `True` in order to stay safe.</span>
<span class="sd">        But since it affects performance quite a bit, you might want to turn</span>
<span class="sd">        validation off when using this function to keep your sanity.</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import read_reference_annotations, extract_tempo</span>
<span class="sd">    &gt;&gt;&gt; smc_ground_truth = read_reference_annotations(&#39;smc_mirex&#39;, validate=False)  # turn validation off for speed</span>
<span class="sd">    &gt;&gt;&gt; smc_1_0_205 = smc_ground_truth[&#39;tempo&#39;][&#39;1.0&#39;][&#39;SMC_205.jams&#39;]  # choose reference version &#39;1.0&#39;</span>
<span class="sd">    &gt;&gt;&gt; tempo = extract_tempo(smc_1_0_205)</span>
<span class="sd">    &gt;&gt;&gt; print(tempo)</span>
<span class="sd">    78.74015748031492</span>

<span class="sd">    .. seealso:: To read estimates, use :py:func:`~tempo_eval.read_estimate_annotations`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">get_references_path</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">,</span> <span class="s1">&#39;jams&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">item_id</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">file_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">read_annotations</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
                            <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                            <span class="n">derive_item_id</span><span class="o">=</span><span class="n">item_id</span><span class="p">,</span>
                            <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_estimate_annotations"><a class="viewcode-back" href="../../generated/tempo_eval.read_estimate_annotations.html#tempo_eval.read_estimate_annotations">[docs]</a><span class="k">def</span> <span class="nf">read_estimate_annotations</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                              <span class="n">namespace</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;tempo&#39;</span><span class="p">,</span>
                              <span class="n">validate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Annotations</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read annotations for estimates.</span>

<span class="sd">    :param corpus_name: corpus name (corresponds to folder name).</span>
<span class="sd">        See :py:func:`~tempo_eval.list_estimate_corpus_names` to get a list of valid names.</span>
<span class="sd">    :param namespace: one or more jam annotation namespace(s), e.g., ``tempo`` for tempo annotations</span>
<span class="sd">        (see `jams namespaces &lt;https://jams.readthedocs.io/en/stable/namespace.html#namespace&gt;`_)</span>
<span class="sd">    :param validate: validate jam while reading (validation impacts performance negatively)</span>
<span class="sd">    :return: jam annotation objects, organized as nested dicts with version and item ids as keys</span>
<span class="sd">    :rtype: dict[str, dict[str, jams.Annotation]]</span>

<span class="sd">    .. note:: By default, `validate` is `True` in order to stay safe.</span>
<span class="sd">        But since it affects performance quite a bit, you might want to turn</span>
<span class="sd">        validation off when using this function to keep your sanity.</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import read_estimate_annotations, extract_tempo</span>
<span class="sd">    &gt;&gt;&gt; smc_estimates = read_estimate_annotations(&#39;smc_mirex&#39;, validate=False)  # turn validation off for speed</span>
<span class="sd">    &gt;&gt;&gt; smc_schreiber2014_205 = smc_estimates[&#39;tempo&#39;][&#39;schreiber2014/default&#39;][&#39;SMC_205.jams&#39;]</span>
<span class="sd">    &gt;&gt;&gt; tempo = extract_tempo(smc_schreiber2014_205)</span>
<span class="sd">    &gt;&gt;&gt; print(tempo)</span>
<span class="sd">    79.7638</span>

<span class="sd">    .. seealso:: To read *reference* values, use :py:func:`~tempo_eval.read_reference_annotations`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">get_estimates_path</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">item_id</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">corpus_version</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">read_annotations</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>
                            <span class="n">namespace</span><span class="o">=</span><span class="n">namespace</span><span class="p">,</span>
                            <span class="n">derive_version</span><span class="o">=</span><span class="n">corpus_version</span><span class="p">,</span>
                            <span class="n">derive_item_id</span><span class="o">=</span><span class="n">item_id</span><span class="p">,</span>
                            <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_reference_tags"><a class="viewcode-back" href="../../generated/tempo_eval.read_reference_tags.html#tempo_eval.read_reference_tags">[docs]</a><span class="k">def</span> <span class="nf">read_reference_tags</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                        <span class="n">validate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TagAnnotations</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read reference tags from the namespaces &#39;tag_open&#39;, &#39;tag_gtzan&#39;, and &#39;tag_fma_genre&#39;.</span>

<span class="sd">    :param corpus_name: corpus</span>
<span class="sd">        See :py:func:`~tempo_eval.list_reference_corpus_names` to get a list of valid names.</span>
<span class="sd">    :param validate: validate jam while reading (validation impacts performance negatively)</span>
<span class="sd">    :return: jam annotation objects, organized as nested dicts with namespace, version and item ids as keys</span>
<span class="sd">    :rtype: dict[str, dict[str, dict[str, jams.Annotation]]]</span>

<span class="sd">    .. note:: By default, `validate` is `True` in order to stay safe.</span>
<span class="sd">        But since it affects performance quite a bit, you might want to turn</span>
<span class="sd">        validation off when using this function to keep your sanity.</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import read_reference_tags, extract_tags</span>
<span class="sd">    &gt;&gt;&gt; gtzan = read_reference_tags(&#39;gtzan&#39;, validate=False)</span>
<span class="sd">    &gt;&gt;&gt; gtzan_hh_691694 = gtzan[&#39;tag_open&#39;][&#39;GTZAN-Rhythm_v2_ismir2015_lbd_2015-10-28&#39;][&#39;hiphop.00086.jams&#39;]</span>
<span class="sd">    &gt;&gt;&gt; tags = extract_tags(gtzan_hh_691694)</span>
<span class="sd">    &gt;&gt;&gt; print(tags)</span>
<span class="sd">    {&#39;4/4&#39;, &#39;no_ternary&#39;, &#39;no_swing&#39;}</span>

<span class="sd">    .. seealso:: To extract tag values, use :py:func:`~tempo_eval.extract_tags`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tag_references</span> <span class="o">=</span> <span class="n">read_reference_annotations</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">,</span>
                                                <span class="n">namespace</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;tag_open&#39;</span><span class="p">,</span> <span class="s1">&#39;tag_gtzan&#39;</span><span class="p">,</span> <span class="s1">&#39;tag_fma_genre&#39;</span><span class="p">],</span>
                                                <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tag_references</span></div>


<span class="k">def</span> <span class="nf">item_ids_for_differing_annotations</span><span class="p">(</span><span class="n">eval_results</span><span class="p">:</span> <span class="n">EvalResults</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find item ids for differing annotations according the results of an evaluation</span>
<span class="sd">    that returns boolean values, like Accuracy1 or Accuracy2.</span>

<span class="sd">    :param eval_results: results as returned by</span>
<span class="sd">        :py:func:`~tempo_eval.evaluation.Metric.eval_tempi`</span>
<span class="sd">    :return: item ids of differing annotations as a nested dict with</span>
<span class="sd">        references and estimator names as keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">reference_version</span> <span class="ow">in</span> <span class="n">eval_results</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">result</span><span class="p">[</span><span class="n">reference_version</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="n">eval_results</span><span class="p">[</span><span class="n">reference_version</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">item_id</span> <span class="ow">in</span> <span class="n">eval_results</span><span class="p">[</span><span class="n">reference_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">estimator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="n">reference_version</span><span class="p">]:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_results</span><span class="p">[</span><span class="n">reference_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">][</span><span class="n">item_id</span><span class="p">])</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">reference_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eval_results</span><span class="p">[</span><span class="n">reference_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">][</span><span class="n">item_id</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">reference_version</span><span class="p">][</span><span class="n">estimator</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">significant_difference</span><span class="p">(</span><span class="n">metric</span><span class="p">:</span> <span class="n">Metric</span><span class="p">,</span> <span class="n">eval_results</span><span class="p">:</span> <span class="n">EvalResults</span><span class="p">,</span>
                           <span class="n">item_id_filter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span>\
        <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate p-values of McNemar&#39;s test. Only applicable for binary</span>
<span class="sd">    metrics like Accuracy1 or Accuracy2, but not for MAPE.</span>

<span class="sd">    .. seealso:: Fabien Gouyon, Anssi P. Klapuri, Simon Dixon, Miguel Alonso,</span>
<span class="sd">        George Tzanetakis, Christian Uhle, and Pedro Cano. `An experimental</span>
<span class="sd">        comparison of audio tempo induction algorithms.</span>
<span class="sd">        &lt;https://www.researchgate.net/profile/Fabien_Gouyon/publication/3457642_An_experimental_comparison_of_audio_tempo_induction_algorithms/links/0fcfd50d982025360f000000/An-experimental-comparison-of-audio-tempo-induction-algorithms.pdf&gt;`_</span>
<span class="sd">        IEEE Transactions on Audio, Speech, and Language Processing,</span>
<span class="sd">        14(5):1832– 1844, 2006.</span>

<span class="sd">    :param metric: metric</span>
<span class="sd">    :param eval_results: results as returned by</span>
<span class="sd">        :py:func:`~tempo_eval.evaluation.Metric.eval_tempi`</span>
<span class="sd">    :param item_id_filter: boolean function that filters item ids</span>
<span class="sd">    :return: p-values in nested dicts with the ground truth,</span>
<span class="sd">        estimator 1 and estimator 2 as keys</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pvalues</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">groundtruth_key</span><span class="p">,</span> <span class="n">algorithms</span> <span class="ow">in</span> <span class="n">eval_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">pvalues</span><span class="p">[</span><span class="n">groundtruth_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># for each groundtruth</span>
        <span class="k">for</span> <span class="n">estimator1</span><span class="p">,</span> <span class="n">results1</span> <span class="ow">in</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pvalues</span><span class="p">[</span><span class="n">groundtruth_key</span><span class="p">][</span><span class="n">estimator1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">filtered_results1</span> <span class="o">=</span> <span class="n">_key_filter</span><span class="p">(</span><span class="n">results1</span><span class="p">,</span> <span class="n">item_id_filter</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">estimator2</span><span class="p">,</span> <span class="n">results2</span> <span class="ow">in</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">estimator1</span> <span class="o">==</span> <span class="n">estimator2</span> <span class="ow">and</span> <span class="n">filtered_results1</span><span class="p">:</span>
                    <span class="c1"># diagonal is always 1</span>
                    <span class="n">ones</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">filtered_results1</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))]</span>
                    <span class="n">pvalues</span><span class="p">[</span><span class="n">groundtruth_key</span><span class="p">][</span><span class="n">estimator1</span><span class="p">][</span><span class="n">estimator2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ones</span>
                <span class="k">elif</span> <span class="n">estimator2</span> <span class="ow">in</span> <span class="n">pvalues</span><span class="p">[</span><span class="n">groundtruth_key</span><span class="p">]:</span>
                    <span class="c1"># exploit symmetry</span>
                    <span class="n">pvalues</span><span class="p">[</span><span class="n">groundtruth_key</span><span class="p">][</span><span class="n">estimator1</span><span class="p">][</span><span class="n">estimator2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pvalues</span><span class="p">[</span><span class="n">groundtruth_key</span><span class="p">][</span><span class="n">estimator2</span><span class="p">][</span><span class="n">estimator1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># actually do some computation</span>
                    <span class="n">filtered_results2</span> <span class="o">=</span> <span class="n">_key_filter</span><span class="p">(</span><span class="n">results2</span><span class="p">,</span> <span class="n">item_id_filter</span><span class="p">)</span>
                    <span class="n">pvalues</span><span class="p">[</span><span class="n">groundtruth_key</span><span class="p">][</span><span class="n">estimator1</span><span class="p">][</span><span class="n">estimator2</span><span class="p">]</span>\
                        <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">significant_difference_function</span><span class="p">(</span><span class="n">filtered_results1</span><span class="p">,</span>
                                                                 <span class="n">filtered_results2</span><span class="p">,</span>
                                                                 <span class="n">estimator1_name</span><span class="o">=</span><span class="n">estimator1</span><span class="p">,</span>
                                                                 <span class="n">estimator2_name</span><span class="o">=</span><span class="n">estimator2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pvalues</span>


<span class="k">def</span> <span class="nf">_key_filter</span><span class="p">(</span><span class="n">dictionary</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function to filter a dict based on its keys.</span>

<span class="sd">    :param dictionary: dict</span>
<span class="sd">    :param predicate: predicate</span>
<span class="sd">    :return: filtered dict</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">key</span><span class="p">)}</span>


<span class="k">def</span> <span class="nf">mcnemar</span><span class="p">(</span><span class="n">estimator1_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalResult</span><span class="p">]],</span>
            <span class="n">estimator2_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalResult</span><span class="p">]],</span>
            <span class="n">estimator1_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;unknown_estimator1&#39;</span><span class="p">,</span>
            <span class="n">estimator2_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;unknown_estimator2&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate McNemar&#39;s p-value for the results of two algorithms.</span>

<span class="sd">    .. seealso:: Fabien Gouyon, Anssi P. Klapuri, Simon Dixon, Miguel Alonso,</span>
<span class="sd">        George Tzanetakis, Christian Uhle, and Pedro Cano. `An experimental</span>
<span class="sd">        comparison of audio tempo induction algorithms.</span>
<span class="sd">        &lt;https://www.researchgate.net/profile/Fabien_Gouyon/publication/3457642_An_experimental_comparison_of_audio_tempo_induction_algorithms/links/0fcfd50d982025360f000000/An-experimental-comparison-of-audio-tempo-induction-algorithms.pdf&gt;`_</span>
<span class="sd">        IEEE Transactions on Audio, Speech, and Language Processing,</span>
<span class="sd">        14(5):1832– 1844, 2006.</span>

<span class="sd">    .. seealso:: `How to Calculate McNemar’s Test to Compare Two Machine Learning Classifiers</span>
<span class="sd">        &lt;https://machinelearningmastery.com/mcnemars-test-for-machine-learning/&gt;`_.</span>

<span class="sd">    :param estimator1_results: estimator 1 eval results</span>
<span class="sd">    :param estimator2_results: estimator 2 eval results</span>
<span class="sd">    :param estimator1_name: name for estimator 1</span>
<span class="sd">    :param estimator2_name: name for estimator 2</span>
<span class="sd">    :return: p values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">contingency_tables</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">relative_jam_file_name</span> <span class="ow">in</span> <span class="n">estimator1_results</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">alg1_correct</span> <span class="o">=</span> <span class="n">estimator1_results</span><span class="p">[</span><span class="n">relative_jam_file_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">relative_jam_file_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimator2_results</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Item only occurs in set </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">, but not in </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">estimator1_name</span><span class="p">,</span> <span class="n">estimator2_name</span><span class="p">,</span>
                                   <span class="n">relative_jam_file_name</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="n">alg2_correct</span> <span class="o">=</span> <span class="n">estimator2_results</span><span class="p">[</span><span class="n">relative_jam_file_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alg1_correct</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contingency_tables</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                <span class="n">contingency_tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">contingency_tables</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">alg1_correct</span><span class="p">[</span><span class="n">i</span><span class="p">])][</span><span class="nb">int</span><span class="p">(</span><span class="n">alg2_correct</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># use binomial or chi_square distribution (threshold=25),</span>
    <span class="c1"># see e.g. https://machinelearningmastery.com/mcnemars-test-for-machine-learning/</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">statsmodels</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">contingency_tables</span><span class="o">.</span><span class="n">mcnemar</span><span class="p">(</span><span class="n">table</span><span class="p">,</span>
                                                     <span class="n">exact</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">25</span><span class="p">,</span>
                                                     <span class="n">correction</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">pvalue</span>
        <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="n">contingency_tables</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">ttest</span><span class="p">(</span><span class="n">estimator1_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalResult</span><span class="p">]],</span>
          <span class="n">estimator2_results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">EvalResult</span><span class="p">]],</span>
          <span class="n">estimator1_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;unknown_estimator1&#39;</span><span class="p">,</span>
          <span class="n">estimator2_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;unknown_estimator2&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate t-test p-value for the results of two algorithms.</span>

<span class="sd">    :param estimator1_results: estimator 1 eval results</span>
<span class="sd">    :param estimator2_results: estimator 2 eval results</span>
<span class="sd">    :param estimator1_name: name for estimator 1</span>
<span class="sd">    :param estimator2_name: name for estimator 2</span>
<span class="sd">    :return: p values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">relative_jam_file_name</span> <span class="ow">in</span> <span class="n">estimator1_results</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">relative_jam_file_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimator2_results</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Item only occurs in set </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">, but not in </span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">estimator1_name</span><span class="p">,</span> <span class="n">estimator2_name</span><span class="p">,</span>
                                   <span class="n">relative_jam_file_name</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">estimator1_results</span><span class="p">[</span><span class="n">relative_jam_file_name</span><span class="p">])</span>
        <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">estimator2_results</span><span class="p">[</span><span class="n">relative_jam_file_name</span><span class="p">])</span>

    <span class="n">np_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">np_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np_a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">np_a</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">np_b</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span>
        <span class="n">a_valid</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
        <span class="n">b_valid</span> <span class="o">=</span> <span class="n">b1</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">a_valid</span><span class="p">,</span> <span class="n">b_valid</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ensure that we compare only valid values</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ttest_rel</span><span class="p">(</span><span class="n">a_valid</span><span class="p">,</span> <span class="n">b_valid</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ps</span>


<span class="k">def</span> <span class="nf">_get_version</span><span class="p">(</span><span class="n">annotation</span><span class="p">:</span> <span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">,</span> <span class="n">include_corpus</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the annotation&#39;s version.</span>
<span class="sd">    If the version is missing, an id is artificially generated by</span>
<span class="sd">    creating a hash from the annotation metadata object.</span>

<span class="sd">    :param include_corpus: include corpus name</span>
<span class="sd">    :param annotation: jams annotation instance</span>
<span class="sd">    :return: a corpus id identifying corpus and version</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">annotation_metadata</span><span class="o">.</span><span class="n">version</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;For a reference dataset, a version should be present to uniquely identify it. </span><span class="si">{}</span><span class="s1">&#39;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">annotation_metadata</span><span class="p">))</span>
        <span class="c1"># artificial corpus name, based on the hash value of the json dump</span>
        <span class="n">v</span> <span class="o">=</span> <span class="s1">&#39;unknown_version(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">annotation_metadata</span><span class="o">.</span><span class="n">dumps</span><span class="p">()))</span>

    <span class="k">if</span> <span class="n">include_corpus</span> <span class="ow">and</span> <span class="n">annotation</span><span class="o">.</span><span class="n">annotation_metadata</span><span class="o">.</span><span class="n">corpus</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">annotation_metadata</span><span class="o">.</span><span class="n">corpus</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">v</span>

    <span class="k">return</span> <span class="n">v</span>


<div class="viewcode-block" id="extract_tags"><a class="viewcode-back" href="../../generated/tempo_eval.extract_tags.html#tempo_eval.extract_tags">[docs]</a><span class="k">def</span> <span class="nf">extract_tags</span><span class="p">(</span><span class="n">tag_annotations</span><span class="p">:</span> <span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract tags from annotations object as set.</span>

<span class="sd">    :param tag_annotations: annotations</span>
<span class="sd">    :return: set of tags</span>
<span class="sd">    :rtype: set[str]</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import read_reference_annotations, extract_tags</span>
<span class="sd">    # choose namespace &#39;tag_gtzan&#39;!</span>
<span class="sd">    &gt;&gt;&gt; gtzan = read_reference_annotations(&#39;gtzan&#39;, namespace=&#39;tag_gtzan&#39;, validate=False)</span>
<span class="sd">    &gt;&gt;&gt; gtzan_hh_691694 = gtzan[&#39;tag_gtzan&#39;][&#39;1.0&#39;][&#39;hiphop.00086.jams&#39;]</span>
<span class="sd">    &gt;&gt;&gt; tags = extract_tags(gtzan_hh_691694)</span>
<span class="sd">    &gt;&gt;&gt; print(tags)</span>
<span class="sd">    {&#39;hip-hop&#39;}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">observation</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">observation</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tag_annotations</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])])</span></div>


<div class="viewcode-block" id="extract_tempo"><a class="viewcode-back" href="../../generated/tempo_eval.extract_tempo.html#tempo_eval.extract_tempo">[docs]</a><span class="k">def</span> <span class="nf">extract_tempo</span><span class="p">(</span><span class="n">tempo_annotations</span><span class="p">:</span> <span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlainTempo</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract the most salient (greatest confidence) tempo value from the annotation.</span>

<span class="sd">    :param tempo_annotations: annotations</span>
<span class="sd">    :return: a tempo value (typically in BPM)</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import read_reference_annotations, extract_tempo</span>
<span class="sd">    &gt;&gt;&gt; smc_ground_truth = read_reference_annotations(&#39;smc_mirex&#39;, validate=False)  # turn validation off for speed</span>
<span class="sd">    &gt;&gt;&gt; smc_1_0_205 = smc_ground_truth[&#39;tempo&#39;][&#39;1.0&#39;][&#39;SMC_205.jams&#39;]  # choose reference version &#39;1.0&#39;</span>
<span class="sd">    &gt;&gt;&gt; tempo = extract_tempo(smc_1_0_205)  # extract single tempo from JAMS annotation</span>
<span class="sd">    &gt;&gt;&gt; print(tempo)</span>
<span class="sd">    78.74015748031492</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observations</span> <span class="o">=</span> <span class="n">tempo_annotations</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">observation_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">observation_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">reference_tempo</span> <span class="o">=</span> <span class="n">observations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
    <span class="k">elif</span> <span class="n">observation_length</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">o0</span> <span class="o">=</span> <span class="n">observations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">o1</span> <span class="o">=</span> <span class="n">observations</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">o0</span><span class="o">.</span><span class="n">confidence</span> <span class="o">&gt;=</span> <span class="n">o1</span><span class="o">.</span><span class="n">confidence</span><span class="p">:</span>
            <span class="n">reference_tempo</span> <span class="o">=</span> <span class="n">o0</span><span class="o">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reference_tempo</span> <span class="o">=</span> <span class="n">o1</span><span class="o">.</span><span class="n">value</span>
    <span class="k">elif</span> <span class="n">observation_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Encountered tempo annotation with no observation in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tempo_annotations</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Don</span><span class="se">\&#39;</span><span class="s1">t know what to do with more than two tempo annotations. Jams: </span><span class="si">{}</span><span class="s1">&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tempo_annotations</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reference_tempo</span></div>


<div class="viewcode-block" id="extract_tempi_and_salience"><a class="viewcode-back" href="../../generated/tempo_eval.extract_tempi_and_salience.html#tempo_eval.extract_tempi_and_salience">[docs]</a><span class="k">def</span> <span class="nf">extract_tempi_and_salience</span><span class="p">(</span><span class="n">tempo_annotations</span><span class="p">:</span> <span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MirexTempo</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract MIREX-style values from the annotations. I.e. ``(t1, t2, s1)``</span>
<span class="sd">    --- tempo 1, tempo 2 and the salience value for tempo1.</span>
<span class="sd">    Tempo values are ordered: ``t1 &lt; t2``.</span>

<span class="sd">    :param tempo_annotations: annotations</span>
<span class="sd">    :return: ``t1, t2, s1``</span>
<span class="sd">    :rtype: (float, float, float)</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt; from tempo_eval import read_reference_annotations, extract_tempi_and_salience</span>
<span class="sd">    &gt;&gt;&gt; gt = read_reference_annotations(&#39;smc_mirex&#39;, validate=False)  # turn validation off for speed</span>
<span class="sd">    &gt;&gt;&gt; gt_691694 = gt[&#39;tempo&#39;][&#39;2.0&#39;][&#39;691694.LOFI.jams&#39;]  # choose reference version &#39;2.0&#39;</span>
<span class="sd">    &gt;&gt;&gt; tempo = extract_tempi_and_salience(gt_691694)  # extract single tempo from JAMS annotation</span>
<span class="sd">    &gt;&gt;&gt; print(tempo)</span>
<span class="sd">    (73.0, 144.0, 0.04228329809725159)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observations</span> <span class="o">=</span> <span class="n">tempo_annotations</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">tempo2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">salience1</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">observation_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">observations</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">observation_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">tempo1</span> <span class="o">=</span> <span class="n">observations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
    <span class="k">elif</span> <span class="n">observation_length</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">tempo1</span> <span class="o">=</span> <span class="n">observations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">tempo2</span> <span class="o">=</span> <span class="n">observations</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">salience1</span> <span class="o">=</span> <span class="n">observations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">confidence</span>
    <span class="k">elif</span> <span class="n">observation_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Encountered tempo annotation with no observation in </span><span class="si">{}</span><span class="s1">&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tempo_annotations</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Don</span><span class="se">\&#39;</span><span class="s1">t know what to do with more than two tempo annotations. Jams: </span><span class="si">{}</span><span class="s1">&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tempo_annotations</span><span class="p">))</span>
    <span class="c1"># MIREX ordering rule</span>
    <span class="k">if</span> <span class="n">tempo1</span> <span class="o">&lt;</span> <span class="n">tempo2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tempo1</span><span class="p">,</span> <span class="n">tempo2</span><span class="p">,</span> <span class="n">salience1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tempo2</span><span class="p">,</span> <span class="n">tempo1</span><span class="p">,</span> <span class="mf">1.</span><span class="o">-</span><span class="n">salience1</span></div>


<div class="viewcode-block" id="extract_tempo_from_beats"><a class="viewcode-back" href="../../generated/tempo_eval.extract_tempo_from_beats.html#tempo_eval.extract_tempo_from_beats">[docs]</a><span class="k">def</span> <span class="nf">extract_tempo_from_beats</span><span class="p">(</span><span class="n">beat_annotations</span><span class="p">:</span> <span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">PlainTempo</span><span class="p">,</span> <span class="n">PlainTempo</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract tempo values from beat annotations using :py:func:`~tempo_eval.evaluation.timestamps_to_bpm`.</span>

<span class="sd">    :param beat_annotations: annotations</span>
<span class="sd">    :return: a BPM value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">observations</span> <span class="o">=</span> <span class="n">beat_annotations</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">timestamps</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observations</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">value</span><span class="p">))</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">observations</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span>
    <span class="n">values_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">values_length</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
        <span class="n">meter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="mi">20</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">values_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">meter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meter</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">timestamps_to_bpm</span><span class="p">(</span><span class="n">timestamps</span><span class="p">,</span> <span class="n">meter</span><span class="o">=</span><span class="n">meter</span><span class="p">)</span></div>


<div class="viewcode-block" id="extract_c_var_from_beats"><a class="viewcode-back" href="../../generated/tempo_eval.extract_c_var_from_beats.html#tempo_eval.extract_c_var_from_beats">[docs]</a><span class="k">def</span> <span class="nf">extract_c_var_from_beats</span><span class="p">(</span><span class="n">annotation_set</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jams</span><span class="o">.</span><span class="n">Annotation</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract coefficient of variations for the beats in the annotation set.</span>

<span class="sd">    :param annotation_set: dict of annotations with annotation name as key</span>
<span class="sd">    :return: nested dicts with set and item names as key and normalized</span>
<span class="sd">        tempo standard deviations as value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">version</span><span class="p">,</span> <span class="n">annotations</span> <span class="ow">in</span> <span class="n">annotation_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">c_vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item_id</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">c_var</span> <span class="o">=</span> <span class="n">extract_tempo_from_beats</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
                <span class="n">c_vars</span><span class="p">[</span><span class="n">item_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_var</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Failed to extract normalized &#39;</span>
                             <span class="s1">&#39;tempo std from annotation </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_vars</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">fraction_lt_c_var</span><span class="p">(</span><span class="n">norm_c_vars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                      <span class="n">thresholds</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fraction of coefficient of variation values below a threshold (lt == less than).</span>

<span class="sd">    :param norm_c_vars: dict with coefficient of variation values per named set</span>
<span class="sd">    :param thresholds: list of thresholds</span>
<span class="sd">    :return: dict with set name as key and list of fractions as value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">version</span><span class="p">:</span> <span class="n">fraction_lt_thresholds</span><span class="p">(</span><span class="n">norm_c_vars</span><span class="p">[</span><span class="n">version</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">thresholds</span><span class="p">)</span> <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">norm_c_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>


<span class="k">def</span> <span class="nf">items_lt_c_var</span><span class="p">(</span><span class="n">beat_annotations</span><span class="p">:</span> <span class="n">Annotations</span><span class="p">,</span>
                   <span class="n">thresholds</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find item ids of those items with a coefficient of variation</span>
<span class="sd">    below a given threshold. If no thresholds are specified, the following</span>
<span class="sd">    expression is used::</span>

<span class="sd">    thresholds = np.arange(0, 0.5, 0.005)</span>

<span class="sd">    :param beat_annotations: dict of annotations with annotation name as key</span>
<span class="sd">    :param thresholds: list of coefficient of variation-thresholds</span>
<span class="sd">    :return: dict with set names as keys and item lists as values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">thresholds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">version</span><span class="p">,</span> <span class="n">annotations</span> <span class="ow">in</span> <span class="n">beat_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">c_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item_id</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">c_var</span> <span class="o">=</span> <span class="n">extract_tempo_from_beats</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
                <span class="n">c_vars</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">item_id</span><span class="p">,</span> <span class="n">c_var</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Failed to extract normalized tempo &#39;</span>
                             <span class="s1">&#39;std from annotation </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">annotation</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c_vars</span>
                                <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">items_in_tempo_intervals</span><span class="p">(</span><span class="n">tempo_annotation_set</span><span class="p">:</span> <span class="n">Annotations</span><span class="p">,</span>
                             <span class="n">intervals</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find item ids with tempo values in given intervals.</span>
<span class="sd">    If no intervals are specified, the following expression is used::</span>

<span class="sd">    intervals = [(s, s + 11) for s in range(0, 289)]</span>

<span class="sd">    :param tempo_annotation_set: dict of annotations with annotation name as key</span>
<span class="sd">    :param intervals: list of intervals, given as tuples</span>
<span class="sd">    :return: dict with set names as keys and item lists as values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">intervals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">11</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">289</span><span class="p">)]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">version</span><span class="p">,</span> <span class="n">annotations</span> <span class="ow">in</span> <span class="n">tempo_annotation_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># create sorted list of tuples</span>
        <span class="n">tempo_items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">extract_tempo</span><span class="p">(</span><span class="n">annotation</span><span class="p">),</span> <span class="n">item_id</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">item_id</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="n">sorted_tempo_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tempo_items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">last_lo</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>

            <span class="c1"># naive implementation:</span>

            <span class="c1"># items = []</span>
            <span class="c1"># for item, tempo in sorted_item_tempo:</span>
            <span class="c1">#     if interval[0] &lt;= tempo &lt;= interval[1]:</span>
            <span class="c1">#         items.append(item)</span>
            <span class="c1"># result[version].append(items)</span>

            <span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">sorted_tempo_items</span><span class="p">,</span> <span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">last_lo</span><span class="p">)</span>
            <span class="n">last_lo</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="k">for</span> <span class="n">tempo_item</span> <span class="ow">in</span> <span class="n">sorted_tempo_items</span><span class="p">[</span><span class="n">pos</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="n">tempo_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempo_item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">items_per_tag</span><span class="p">(</span><span class="n">tag_reference_set</span><span class="p">:</span> <span class="n">Annotations</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find list of item ids per tag.</span>

<span class="sd">    :param tag_reference_set: tag reference set</span>
<span class="sd">    :return: nested dicts with annotations name and tag name as</span>
<span class="sd">        keys and list of item ids as values</span>
<span class="sd">    :rtype: dict[str, dict[str, set[str]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">version</span><span class="p">,</span> <span class="n">annotations</span> <span class="ow">in</span> <span class="n">tag_reference_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item_id</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="n">extract_tags</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">]:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="n">item_id</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">version</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">item_id</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">fraction_lt_thresholds</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                           <span class="n">thresholds</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
                           <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates what fraction of items is less than a given</span>
<span class="sd">    threshold for a list of thresholds.</span>

<span class="sd">    :param values: values</span>
<span class="sd">    :param thresholds: iterable of thresholds</span>
<span class="sd">    :param key: key function to extract the attribute to sort by</span>
<span class="sd">    :return: list of fractions corresponding to the given thresholds</span>
<span class="sd">    :rtype: list[float]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">sorted_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">values_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">sorted_list</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">fraction</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">values_list</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fraction</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">basic_statistics</span><span class="p">(</span><span class="n">tempo_annotation_set</span><span class="p">:</span> <span class="n">Annotations</span><span class="p">,</span>
                     <span class="n">estimates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate basic statistics about a set of annotations, incl.</span>
<span class="sd">    number of tracks, min BPM value, max BPM value, sweet octave start</span>
<span class="sd">    (:py:func:`~tempo_eval.evaluation.sweet_octave`), etc.</span>

<span class="sd">    :param tempo_annotation_set: set of tempo annotations</span>
<span class="sd">    :param estimates: boolean flag indicating whether the annotations are</span>
<span class="sd">        estimates or reference annotations</span>
<span class="sd">    :return: a DataFrame with the desired values</span>
<span class="sd">    :rtype: pandas.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Size&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Min&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Max&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Avg&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Stdev&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Sweet Oct. Start&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;Sweet Oct. Coverage&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="p">}</span>
    <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">tempo_annotation_set</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="n">tempo_annotation_set</span><span class="p">[</span><span class="n">version</span><span class="p">]</span>
        <span class="c1"># ignore 0.0 BPM estimates.</span>
        <span class="n">tempi</span> <span class="o">=</span> <span class="p">[</span><span class="n">extract_tempo</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                 <span class="k">if</span> <span class="n">extract_tempo</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">]</span>
        <span class="n">octave</span><span class="p">,</span> <span class="n">percentage</span> <span class="o">=</span> <span class="n">sweet_octave</span><span class="p">(</span><span class="n">tempi</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">tempi</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tempi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sdev</span> <span class="o">=</span> <span class="n">stdev</span><span class="p">(</span><span class="n">tempi</span><span class="p">,</span> <span class="n">xbar</span><span class="o">=</span><span class="n">avg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">values</span><span class="p">[</span><span class="s1">&#39;Size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tempi</span><span class="p">))</span>
        <span class="n">values</span><span class="p">[</span><span class="s1">&#39;Min&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">tempi</span><span class="p">)))</span>
        <span class="n">values</span><span class="p">[</span><span class="s1">&#39;Max&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">tempi</span><span class="p">)))</span>
        <span class="n">values</span><span class="p">[</span><span class="s1">&#39;Avg&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">avg</span><span class="p">))</span>
        <span class="n">values</span><span class="p">[</span><span class="s1">&#39;Stdev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
        <span class="n">values</span><span class="p">[</span><span class="s1">&#39;Sweet Oct. Start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">octave</span><span class="p">))</span>
        <span class="n">values</span><span class="p">[</span><span class="s1">&#39;Sweet Oct. Coverage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">percentage</span><span class="p">))</span>

    <span class="n">values_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
    <span class="n">values_df</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Basic Statistics&#39;</span>
    <span class="k">if</span> <span class="n">estimates</span><span class="p">:</span>
        <span class="n">values_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Estimator&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Reference&#39;</span>
    <span class="k">return</span> <span class="n">values_df</span>


<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">sweet_octave</span><span class="p">(</span><span class="n">tempi</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the *sweet octave*, i.e. the tempo interval ``[j,2j)`` that contains</span>
<span class="sd">    more of the dataset’s songs than any other octave, and its coverage of the dataset.</span>
<span class="sd">    If more than one such interval exists, the one with the lowest ``j`` is returned.</span>
<span class="sd">    Infinity and NaN values are ignored when calculatig the *sweet octave*, but</span>
<span class="sd">    are taken into consideration when calculating coverage.</span>

<span class="sd">    .. seealso:: Hendrik Schreiber, Meinard Müller. `A Post-Processing Procedure for</span>
<span class="sd">        Improving Music Tempo Estimates Using Supervised Learning.</span>
<span class="sd">        &lt;https://www.audiolabs-erlangen.de/content/05-fau/professor/00-mueller/03-publications/2017_SchreiberM_TempoEstimation_ISMIR.pdf&gt;`_</span>
<span class="sd">        In Proceedings of the 18th International Society for Music Information</span>
<span class="sd">        Retrieval Conference (ISMIR), pages 235–242, Suzhou, China, October 2017.</span>

<span class="sd">    :param tempi: list of tempi</span>
<span class="sd">    :return: sweet octave start, dataset coverage</span>
<span class="sd">    :rtype: (float, float)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_in_octave</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_octave</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">octave_start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tempi</span>
                                                <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                                                   <span class="ow">and</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">)]))):</span>
        <span class="n">in_octave</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tempi</span> <span class="k">if</span> <span class="n">octave_start</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">octave_start</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">in_octave</span> <span class="o">&gt;</span> <span class="n">max_in_octave</span><span class="p">:</span>
            <span class="n">max_in_octave</span> <span class="o">=</span> <span class="n">in_octave</span>
            <span class="n">max_octave</span> <span class="o">=</span> <span class="n">octave_start</span>
    <span class="k">return</span> <span class="n">max_octave</span><span class="p">,</span> <span class="n">max_in_octave</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tempi</span><span class="p">))</span>


<span class="n">ACC1</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;Accuracy1&#39;</span><span class="p">,</span>
              <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;Accuracy&lt;sub&gt;1&lt;/sub&gt;&#39;</span><span class="p">,</span>
              <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Accuracy&lt;sub&gt;1&lt;/sub&gt; is defined as the percentage &#39;</span>
                          <span class="s1">&#39;of correct estimates, allowing a 4% tolerance for &#39;</span>
                          <span class="s1">&#39;individual BPM values.&#39;</span><span class="p">,</span>
              <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
              <span class="n">eval_function</span><span class="o">=</span><span class="n">equal1</span><span class="p">,</span>
              <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
              <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">mcnemar</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Accuracy 1.&quot;&quot;&quot;</span>

<span class="n">ACC2</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;Accuracy2&#39;</span><span class="p">,</span>
              <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;Accuracy&lt;sub&gt;2&lt;/sub&gt;&#39;</span><span class="p">,</span>
              <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Accuracy&lt;sub&gt;2&lt;/sub&gt; additionally permits &#39;</span>
                          <span class="s1">&#39;estimates to be wrong by a factor of 2, 3, &#39;</span>
                          <span class="s1">&#39;1/2 or 1/3 &#39;</span>
                          <span class="s1">&#39;(so-called *octave errors*).&#39;</span><span class="p">,</span>
              <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
              <span class="n">eval_function</span><span class="o">=</span><span class="n">equal2</span><span class="p">,</span>
              <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
              <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">mcnemar</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Accuracy 2.&quot;&quot;&quot;</span>

<span class="n">APE1</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;APE1&#39;</span><span class="p">,</span> <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;APE&lt;sub&gt;1&lt;/sub&gt;&#39;</span><span class="p">,</span>
              <span class="n">description</span><span class="o">=</span><span class="s1">&#39;APE&lt;sub&gt;1&lt;/sub&gt; is defined as absolute &#39;</span>
                          <span class="s1">&#39;percentage error between an estimate &#39;</span>
                          <span class="s1">&#39;and a reference value: &#39;</span>
                          <span class="s1">&#39;&lt;code&gt;APE&lt;sub&gt;1&lt;/sub&gt;(E) = |(E-R)/R|&lt;/code&gt;.&#39;</span><span class="p">,</span>
              <span class="n">best_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
              <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
              <span class="n">eval_function</span><span class="o">=</span><span class="n">ape1</span><span class="p">,</span>
              <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
              <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Absolute percentage error 1 (APE1).&quot;&quot;&quot;</span>

<span class="n">APE2</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;APE2&#39;</span><span class="p">,</span> <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;APE&lt;sub&gt;2&lt;/sub&gt;&#39;</span><span class="p">,</span>
              <span class="n">description</span><span class="o">=</span><span class="s1">&#39;APE&lt;sub&gt;2&lt;/sub&gt; is the minimum of &#39;</span>
                          <span class="s1">&#39;APE&lt;sub&gt;1&lt;/sub&gt; allowing the octave &#39;</span>
                          <span class="s1">&#39;errors 2, 3, 1/2, and 1/3: &#39;</span>
                          <span class="s1">&#39;&lt;code&gt;APE&lt;sub&gt;2&lt;/sub&gt;(E) = min(&#39;</span>
                          <span class="s1">&#39;APE&lt;sub&gt;1&lt;/sub&gt;(E), APE&lt;sub&gt;1&lt;/sub&gt;(2E), &#39;</span>
                          <span class="s1">&#39;APE&lt;sub&gt;1&lt;/sub&gt;(3E), APE&lt;sub&gt;1&lt;/sub&gt;(&amp;frac12;E), &#39;</span>
                          <span class="s1">&#39;APE&lt;sub&gt;1&lt;/sub&gt;(&amp;frac13;E))&lt;/code&gt;.&#39;</span><span class="p">,</span>
              <span class="n">best_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
              <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
              <span class="n">eval_function</span><span class="o">=</span><span class="n">ape2</span><span class="p">,</span>
              <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
              <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Absolute percentage error 2 (APE2), allowing octave errors.&quot;&quot;&quot;</span>

<span class="n">PE1</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;PE1&#39;</span><span class="p">,</span> <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;PE&lt;sub&gt;1&lt;/sub&gt;&#39;</span><span class="p">,</span>
             <span class="n">description</span><span class="o">=</span><span class="s1">&#39;PE&lt;sub&gt;1&lt;/sub&gt; is defined as percentage &#39;</span>
                         <span class="s1">&#39;error between an estimate &lt;code&gt;E&lt;/code&gt; and a &#39;</span>
                         <span class="s1">&#39;reference value &lt;code&gt;R&lt;/code&gt;: &#39;</span>
                         <span class="s1">&#39;&lt;code&gt;PE&lt;sub&gt;1&lt;/sub&gt;(E) = (E-R)/R&lt;/code&gt;.&#39;</span><span class="p">,</span>
             <span class="n">best_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
             <span class="n">eval_function</span><span class="o">=</span><span class="n">pe1</span><span class="p">,</span>
             <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
             <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Percentage error 1 (PE1).&quot;&quot;&quot;</span>

<span class="n">PE2</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;PE2&#39;</span><span class="p">,</span> <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;PE&lt;sub&gt;2&lt;/sub&gt;&#39;</span><span class="p">,</span>
             <span class="n">description</span><span class="o">=</span><span class="s1">&#39;PE&lt;sub&gt;2&lt;/sub&gt; is the signed PE&lt;sub&gt;1&lt;/sub&gt; &#39;</span>
                         <span class="s1">&#39;corresponding to the minimum absolute &#39;</span>
                         <span class="s1">&#39;PE&lt;sub&gt;1&lt;/sub&gt; allowing the octave&#39;</span>
                         <span class="s1">&#39;errors 2, 3, 1/2, and 1/3: &#39;</span>
                         <span class="s1">&#39;&lt;code&gt;PE&lt;sub&gt;2&lt;/sub&gt;(E) = arg min&lt;sub&gt;x&lt;/sub&gt;(|x|) with x ∈ &#39;</span>
                         <span class="s1">&#39;{PE&lt;sub&gt;1&lt;/sub&gt;(E), PE&lt;sub&gt;1&lt;/sub&gt;(2E), &#39;</span>
                         <span class="s1">&#39;PE&lt;sub&gt;1&lt;/sub&gt;(3E), PE&lt;sub&gt;1&lt;/sub&gt;(&amp;frac12;E), &#39;</span>
                         <span class="s1">&#39;PE&lt;sub&gt;1&lt;/sub&gt;(&amp;frac13;E)}&lt;/code&gt;&#39;</span><span class="p">,</span>
             <span class="n">best_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
             <span class="n">eval_function</span><span class="o">=</span><span class="n">pe2</span><span class="p">,</span>
             <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
             <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Percentage error 2 (PE2), allowing octave errors.&quot;&quot;&quot;</span>

<span class="n">OE1</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;OE1&#39;</span><span class="p">,</span> <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;OE&lt;sub&gt;1&lt;/sub&gt;&#39;</span><span class="p">,</span>
             <span class="n">description</span><span class="o">=</span><span class="s1">&#39;OE&lt;sub&gt;1&lt;/sub&gt; is defined as octave &#39;</span>
                         <span class="s1">&#39;error between an estimate &lt;code&gt;E&lt;/code&gt; and a &#39;</span>
                         <span class="s1">&#39;reference value &lt;code&gt;R&lt;/code&gt;.&#39;</span>
                         <span class="s1">&#39;This means that the most common errors&#39;</span>
                         <span class="s1">&#39;&amp;mdash;by a factor of 2 or &amp;frac12;&amp;mdash;&#39;</span>
                         <span class="s1">&#39;have the same magnitude, namely 1: &#39;</span>
                         <span class="s1">&#39;&lt;code&gt;OE&lt;sub&gt;2&lt;/sub&gt;(E) = log&lt;sub&gt;2&lt;/sub&gt;(E/R)&lt;/code&gt;.&#39;</span><span class="p">,</span>
             <span class="n">best_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;TO&#39;</span><span class="p">,</span>
             <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
             <span class="n">eval_function</span><span class="o">=</span><span class="n">oe1</span><span class="p">,</span>
             <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
             <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Octave error 1 (OE1).&quot;&quot;&quot;</span>

<span class="n">OE2</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;OE2&#39;</span><span class="p">,</span> <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;OE&lt;sub&gt;2&lt;/sub&gt;&#39;</span><span class="p">,</span>
             <span class="n">description</span><span class="o">=</span><span class="s1">&#39;OE&lt;sub&gt;2&lt;/sub&gt; is the signed OE&lt;sub&gt;1&lt;/sub&gt; &#39;</span>
                         <span class="s1">&#39;corresponding to the minimum absolute &#39;</span>
                         <span class="s1">&#39;OE&lt;sub&gt;1&lt;/sub&gt; allowing the octave&#39;</span>
                         <span class="s1">&#39;errors 2, 3, 1/2, and 1/3: &#39;</span>
                         <span class="s1">&#39;&lt;code&gt;OE&lt;sub&gt;2&lt;/sub&gt;(E) = &#39;</span>
                         <span class="s1">&#39;arg min&lt;sub&gt;x&lt;/sub&gt;(|x|) with x ∈ &#39;</span>
                         <span class="s1">&#39;{OE&lt;sub&gt;1&lt;/sub&gt;(E), OE&lt;sub&gt;1&lt;/sub&gt;(2E), &#39;</span>
                         <span class="s1">&#39;OE&lt;sub&gt;1&lt;/sub&gt;(3E), OE&lt;sub&gt;1&lt;/sub&gt;(&amp;frac12;E), &#39;</span>
                         <span class="s1">&#39;OE&lt;sub&gt;1&lt;/sub&gt;(&amp;frac13;E)}&lt;/code&gt;&#39;</span><span class="p">,</span>
             <span class="n">best_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;TO&#39;</span><span class="p">,</span>
             <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
             <span class="n">eval_function</span><span class="o">=</span><span class="n">oe2</span><span class="p">,</span>
             <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
             <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Octave error 2 (OE2).&quot;&quot;&quot;</span>

<span class="n">AOE1</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;AOE1&#39;</span><span class="p">,</span> <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;AOE&lt;sub&gt;1&lt;/sub&gt;&#39;</span><span class="p">,</span>
              <span class="n">description</span><span class="o">=</span><span class="s1">&#39;AOE&lt;sub&gt;1&lt;/sub&gt; is defined as absolute &#39;</span>
                          <span class="s1">&#39;octave error between an estimate &#39;</span>
                          <span class="s1">&#39;and a reference value: &#39;</span>
                          <span class="s1">&#39;&lt;code&gt;AOE&lt;sub&gt;1&lt;/sub&gt;(E) = &#39;</span>
                          <span class="s1">&#39;|log&lt;sub&gt;2&lt;/sub&gt;(E/R)|&lt;/code&gt;.&#39;</span><span class="p">,</span>
              <span class="n">best_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
              <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;TO&#39;</span><span class="p">,</span>
              <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
              <span class="n">eval_function</span><span class="o">=</span><span class="n">aoe1</span><span class="p">,</span>
              <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
              <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Absolute octave error 1 (AOE1).&quot;&quot;&quot;</span>

<span class="n">AOE2</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;AOE2&#39;</span><span class="p">,</span> <span class="n">formatted_name</span><span class="o">=</span><span class="s1">&#39;AOE&lt;sub&gt;2&lt;/sub&gt;&#39;</span><span class="p">,</span>
              <span class="n">description</span><span class="o">=</span><span class="s1">&#39;AOE&lt;sub&gt;2&lt;/sub&gt; is the minimum of &#39;</span>
                          <span class="s1">&#39;AOE&lt;sub&gt;1&lt;/sub&gt; allowing the octave &#39;</span>
                          <span class="s1">&#39;errors 2, 3, 1/2, and 1/3: &#39;</span>
                          <span class="s1">&#39;&lt;code&gt;AOE&lt;sub&gt;2&lt;/sub&gt;(E) = min(&#39;</span>
                          <span class="s1">&#39;AOE&lt;sub&gt;1&lt;/sub&gt;(E), AOE&lt;sub&gt;1&lt;/sub&gt;(2E), &#39;</span>
                          <span class="s1">&#39;AOE&lt;sub&gt;1&lt;/sub&gt;(3E), AOE&lt;sub&gt;1&lt;/sub&gt;(&amp;frac12;E), &#39;</span>
                          <span class="s1">&#39;AOE&lt;sub&gt;1&lt;/sub&gt;(&amp;frac13;E))&lt;/code&gt;.&#39;</span><span class="p">,</span>
              <span class="n">best_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
              <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;TO&#39;</span><span class="p">,</span>
              <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_single_bpm</span><span class="p">,</span>
              <span class="n">eval_function</span><span class="o">=</span><span class="n">aoe2</span><span class="p">,</span>
              <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempo</span><span class="p">,</span>
              <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Absolute octave error 2 (AOE2).&quot;&quot;&quot;</span>

<span class="n">PSCORE</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;P-Score&#39;</span><span class="p">,</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">p_score</span><span class="p">,</span>
                <span class="n">description</span><span class="o">=</span><span class="s1">&#39;P-Score is defined as the average of two tempi weighted by &#39;</span>
                            <span class="s1">&#39;their perceptual strength, allowing an 8% tolerance for &#39;</span>
                            <span class="s1">&#39;both tempo values &#39;</span>
                            <span class="s1">&#39;[[MIREX 2006 Definition]&#39;</span>
                            <span class="s1">&#39;(https://www.music-ir.org/mirex/wiki/2006:Audio_Tempo_Extraction#Evaluation_Procedures)].&#39;</span><span class="p">,</span>
                <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_mirex_style</span><span class="p">,</span>
                <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempi_and_salience</span><span class="p">,</span>
                <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">ttest</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;P-Score.&quot;&quot;&quot;</span>

<span class="n">ONE_CORRECT</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;One Correct&#39;</span><span class="p">,</span>
                     <span class="n">description</span><span class="o">=</span><span class="s1">&#39;One Correct is the fraction of estimate &#39;</span>
                                 <span class="s1">&#39;pairs of which at least one of the two &#39;</span>
                                 <span class="s1">&#39;values is equal to a reference value &#39;</span>
                                 <span class="s1">&#39;(within an 8% tolerance).&#39;</span><span class="p">,</span>
                     <span class="n">eval_function</span><span class="o">=</span><span class="n">one_correct</span><span class="p">,</span>
                     <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_mirex_style</span><span class="p">,</span>
                     <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempi_and_salience</span><span class="p">,</span>
                     <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">mcnemar</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;One of two estimates correct.&quot;&quot;&quot;</span>

<span class="n">BOTH_CORRECT</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="s1">&#39;Both Correct&#39;</span><span class="p">,</span>
                      <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Both Correct is the fraction of estimate &#39;</span>
                                  <span class="s1">&#39;pairs of which both &#39;</span>
                                  <span class="s1">&#39;values are equal to the reference values &#39;</span>
                                  <span class="s1">&#39;(within an 8% tolerance).&#39;</span><span class="p">,</span>
                      <span class="n">eval_function</span><span class="o">=</span><span class="n">both_correct</span><span class="p">,</span>
                      <span class="n">extract_function</span><span class="o">=</span><span class="n">extract_tempi_and_salience</span><span class="p">,</span>
                      <span class="n">suitability_function</span><span class="o">=</span><span class="n">is_mirex_style</span><span class="p">,</span>
                      <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">significant_difference_function</span><span class="o">=</span><span class="n">mcnemar</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Both correct.&quot;&quot;&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, tempo_eval contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>